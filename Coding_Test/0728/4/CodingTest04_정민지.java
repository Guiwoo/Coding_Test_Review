// 문제는 끝까지 도달할 수 있는가?!입니다.
class Solution {
    public boolean solution(int[] param0) {
      // 지금 최대 얼마나 움직일 수 있을까에 대한 변수입니다.
        int move = 0;
        /*
            move가 i보다 크거나 같을 동안 돕니다.
            어떠한 시작점으로 부터 move가 현재 시작점에서 +n만큼 이동했을 때
            시작점에서 +n까지는 내가 n까지 이동하면서 이용할 수 있는 일종의 자원들입니다.
         */
        for (int i = 0; i <= move; i++) {
          /*
            얼만큼 움직였을까? 가지고 있는 move 값과 i + param0[i]을 비교합니다.
            move의 값은 기존 move 값과 i + param0[i]을 비교하게 되는데요.
            내가 지금 move만큼 이동을 할 수 있지만 그 시작 지점에서 move까지의 사이를
            i를 통해 다시 하나씩 훑어보며 왔을 때 더 빠르게 더 멀리 이동할 수 있는 방법이
            있을 수도 있기 때문입니다. (어쩌면 끝까지)

            이해를 돕기 위해 예시를 들어보자면 nums = {3, 4, 1, 1, 0, 3} 처음 시작은
            0과 0 + 3 (i 위치 0이고 3만큼 움직일 수 있습니다.)
            그래서 move는 3만큼 움직여서 3이 됩니다.
            move가 현재 끝까지 도달했나요? 아니라서 다시 반복문으로 들어옵니다.
            3과 1 + 4 (최대 3까지 움직일 수 있고 i 위치 1에서 4만큼 움직일 수 있습니다.)
            그래서 비교를 했는데 3만큼 바로 움직인 것보다 1번째에서 다시 한 번 움직이는 것이
            (1 + 4) 크기 때문에 0 -> 3으로 가는게 아닌 0 -> 1
            move는 5가 됩니다. length와 비교하니 끝까지 도달했습니다. return true;
            0 -> 1 -> 5

            ---

            다른 예시를 들어보자면 nums = {0, 5, 4, 3, 6, 7} 처음 시작은
            0과 0 + 0
            그래서 움직일 수 없기 때문에 그대로 return false;

            ---

            다른 예시를 또 들어보자면 nums = {5, 3, 1, 2, 5, 5} 처음 시작은
            0과 0 + 5
            move는 5, 마지막 인덱스 번호와 같으니까 그대로 return true;

          */
            move = Math.max(move, i + param0[i]);
            if (move >= param0.length - 1) {
                return true;
            }
        }
        return false;
    }
}
